  # Mini Projet Kubernetes
  <div align="center"><img src="images/wp_k8s.png"></div><br/>

  Ce Projet denomm√© mini projet Kubernetes a √©t√© r√©alis√© dans le cadre de mon      parcours **Devops** au **Bootcamp N¬∞15 de EAZYTraining**   
  
  ## Objectifs

 Il s'agit ici de deployer **WordPress** √† l'aide manifest selon les informations ci-dessous: 
- Cr√©er un objet de type Deployment pour MySQL avec un seul replicas 
- Cr√©er un objet de type Service de type **clusterIP** pour exposer le **Pod MySQL**
- Cr√©er un objet de type Deployment avec un seul replicas pour **WordPress** avec les param√®tres de connexion √† **MySQL**
- Les donn√©es de WordPress seront stock√©es dans le r√©pertoire /data du Noeud
- Cr√©er un service de type **NodePort** pour exposer **WordPress**

## Get Started üöÄ  

J'ai apport√© un changement en ajoutant un **Namespace** pour cloisonner l'application WordPress (voir ci-dessous).

## Architecture 

<div align="center"><img src="images/wp-k8s-31.jpg" width=1000px></div>

## Plan de Travail
1 - D√©ploiement de l'environnement k8s

2 - Ecriture des manifests nec√©ssaires au deploiemnt de **MySQL** et de **Wordpress**

3 - D√©ploiement de **Wordpress**

## T√¢ches r√©alis√©es
### 1 - Installation de l'environnement k8s

Comme environnement j'ai opt√© pour **Minikube et VirtualBox** qui permet d'avoir un cluster Mono Node pour la r√©alisation de ce projet.

- T√©l√©chargement et installation de **Minikube**
```
mkdir Minikube && cd Minikube
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
```
- D√©marrage de Minikube et Test

```
minikube start --driver=virtualbox
```
```
gbane@dev-ops:~$ kubectl get pods --all-namespaces 
NAMESPACE     NAME                               READY   STATUS      RESTARTS       AGE
kube-system   coredns-5dd5756b68-6ttl7           0/1     Completed   6              3d
kube-system   etcd-minikube                      0/1     Running     7 (84s ago)    3d
kube-system   kube-apiserver-minikube            0/1     Running     7 (74s ago)    3d
kube-system   kube-controller-manager-minikube   0/1     Running     7 (84s ago)    3d
kube-system   kube-proxy-8f5np                   1/1     Running     7 (84s ago)    3d
kube-system   kube-scheduler-minikube            0/1     Running     7 (84s ago)    3d
kube-system   storage-provisioner                1/1     Running     14 (84s ago)   3d

```
L'environnement √©tant deploy√© je procedonsvais proc√©der √† l'√©criture des manifests

### 2 - Ecriture des Manisfests
**1 - Namespace**

Comme r√©commend√© en environnement de Production  j'ai cloisonn√© les Pods dans des espaces de nom diff√©rent en cr√©ant un **Namespace** appel√© **wordpress**.
Ce cloisonnement permet d'avoir des unit√©s logiques, allouer des ressources,organiser , g√©rer et secuiriser le cluster.

Cr√©ons le fichier **wp-namespace.yml** et ajoutons le contenu ci-dessous

- Cr√©ation du fichier 
```
mkdir -p mini-projet-k8s && cd mini-projet-k8s
touch wp-namespace.yml
```
- Contenu du fichier
```
---
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress
status:
  phase: Active
```
- Enr√©gistrons le fichier et proc√©dons √† la cr√©ation du Namespace
```
kubectl apply -f wp-namespace.yml
```
v√©rification

```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get namespaces 
NAME              STATUS   AGE
default           Active   3d18h
kube-node-lease   Active   3d18h
kube-public       Active   3d18h
kube-system       Active   3d18h
wordpress         Active   28m
```
A partir de cet instant tous les objets seront cr√©es dans le Namespace **wordpress**

**2 - D√©ploiment de MySQL**

√Ä l'instar de  **PostgreSQL**, **Oracle** et autres, **MySQL** est une application √† √©tat **(Stateful)** qui n√©cessite de stocker et suivre des donn√©es de fa√ßon permanente contrairement aux applications sans √©tat **(Stateless)** comme **Nginx**.

Supposons que nous voulons d√©ployer une base de donn√©es **MySQL** dans le **cluster Kubernetes** avec trois **r√©plicas**. Lorsqu'une application frontale souhaite acc√©der au cluster MySQL pour lire et √©crire des donn√©es. La demande de lecture sera transmise √† trois pods. Cependant, la demande d'√©criture ne sera transmise qu'au **premier Pod (principal)** et les donn√©es seront synchronis√©es avec les autres pods. 

**Pour y parvenir nous allons utiliser des StatefulSets et non des Deployment**

La suppression ou la r√©duction d'un StatefulSet ne supprimera pas les volumes associ√©s √† l'application avec √©tat. Cela nous assure la s√©curit√© de nos donn√©es. Si on supprime le Pod MySQL ou si le Pod MySQL red√©marre, nous aurons toujours acc√®s aux donn√©es du m√™me volume.

Les applications qui se connectent √† la base de donn√©es devront toujours se connecter au Pod qui joue le r√¥le principal afin de recevoir un acc√®s en lecture-√©criture, ce probl√®me est r√©solu par le **StatefulSet** en attribuant √† chaque pod une identit√© r√©seau pr√©visible et coh√©rente sous la forme ***<statefulset-name>-<pod-ordinal-index>*** √† la diff√©rence du **Deployment** qui attribue des noms sous forme ***<deployment-name>-<index al√©atoir>***.

Exemple nos 3 replicas seront nomm√©s comme ci-dessous:

- ```mysql-0``` - First Pod, in the primary role
- ```mysql-1``` - Read-only replica
- ```mysql-2``` - Read-only replica

Avant de cr√©er un **StatefulSet** nous devons provisionner un espace de stockage appel√© **Volume** pour la persistence des donn√©es de notre Base de donn√©es.

Pour ce faire nous allons cr√©er un objet de type **PVC (PersistentVolumeClaim)** en utilisant le **HostPath Provisionner** qui est le **StorageClass** install√© par d√©fault sur notre cluster .


**a - PVC PersistentVolumeClaim**

Cr√©ons le fichier **mysql-pvc.yml** et ajoutons le contenu ci-dessous
- cr√©ons le fichier
```
touch mysql-pvc.yml
```
- contenu du fichier
```
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: wordpress
  labels:
    app: mysql
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```
- **storage: 10Gi** ici nous requetons 10Gi de stockage
- **accessModes:** **- ReadWriteOnce** le volume peut √™tre mont√© en lecture-√©criture par un seul n≈ìud.

```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl apply -f mysql-pvc.yml
persistentvolumeclaim/mysql-pvc created
```
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get pvc -n wordpress 
NAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
mysql-pvc   Bound    pvc-20e435d1-d691-4f0c-a96c-837169c240de   10Gi       RWO            standard       38s
```
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get pv
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS        CLAIM                 STORAGECLASS   REASON   AGE
pvc-20e435d1-d691-4f0c-a96c-837169c240de   10Gi       RWO            Delete           Bound         wordpress/mysql-pvc   standard                3h9m
```

**b - Secret**

Maintenant que notre volume est cr√©e , nous allons cr√©er un objet de type secret pour stocker les param√®tres de connexion **MySQL**. 

*(Dans un environnement de production il est recomend√© d'utiliser **HashiCorp Vault)*** car les donn√©es de type secret sont faciles √† d√©coder

Cr√©ons le fichier mysql-secret.yml et son contenu, il faut noter que mots de passe doivent √™tre au format **Base64** qu'on peut g√©n√©rer avec la commande ci-dessous

```
echo -n "password"|base64
``` 
- Cr√©ons le ficher mysql-secret.yml

```
touch secret-pvc.yml
```
- ajoutons le contenu ci-dessous 
```
---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
  namespace: wordpress
type: Opaque
data:
  password: eW91cl9zZWN1cmVfcGFzc3dvcmQ=
  mysql-password: cGFzc3dvcmQ=
```
cr√©ons et v√©rifions le secret
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl apply -f mysql-secret.yml 
secret/mysql-pass created
```
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get -n wordpress secrets 
NAME         TYPE     DATA   AGE
mysql-pass   Opaque   2      153m
```
**c - StatefulSet**

Je vais Maintenant proc√©der √† la cr√©ation du statefulset.

- Cr√©ation du fichier **mysql-sts.yml**
```
touch mysql-sts.yml
```
- Contenu du StatefulSet
```
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
  namespace: wordpress
  labels:
    app: mysql
spec:
  serviceName: mysql
  selector:
    matchLabels:
      app: mysql
  replicas: 1
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: mysql:8.0
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wordpress
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
```
Voici quelques points √† noter :

1 - **kind: StatefulSet** d√©mande √† Kubernetes de cr√©er une application MySQL avec les caract√©ristiques de **StatefulSet**

2 - **replicas: 1** permettra de cr√©er un seul Pod sera nomm√© sous le format <statefulset-name>-<pod-ordinal-index> donc **mysql-0**

3 - **MYSQL_ROOT_PASSWORD et MYSQL_PASSWORD** les mots de passe sont extrait de l'objet Secret mysql-pass √† l'aide de la ref√©rence **secretKeyRef**.

4 - **volumeMounts et volumes** permettrons au r√©pertoire */var/lib/mysql* du StatefulSet MySQL d'√™tre mont√© dans le volume **mysql-pvc** qui a √©t√© pr√©c√©demment cr√©e.

√† l'aide de la commande kubectl on cr√©e le StatefulSet

```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl apply -f mysql-sts.yml 
statefulset.apps/mysql created
```
- v√©rification de la cr√©ation du statefulset
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get -n wordpress sts
NAME    READY   AGE
mysql   1/1     2m54s
```
- v√©rification de la cr√©ation du Pod
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get -n wordpress pods
NAME      READY   STATUS    RESTARTS   AGE
mysql-0   1/1     Running   0          4m18s
```
**d - Service mysql**

Pour permettre la communication entre WordPress et MySQL , on va cr√©er un service de type **clusterIP** qui exposera mysql seulement au niveau du cluster

- cr√©ation du fichier mysql-service.yml
```
touch mysql-service.yml
```
- contenu du fichier
```
---
apiVersion: v1
kind: Service
metadata:
  name: mysql-svc
  namespace: wordpress
  labels:
    app: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
  type: ClusterIP
```
- cr√©ation du service **mysql-svc**
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl apply -f mysql-service.yml 
service/mysql-svc created
```
- v√©rification de la cr√©ation du service
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get -n wordpress svc
NAME        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
mysql-svc   ClusterIP   10.111.165.124   <none>        3306/TCP   99s
```
**e - PVC pour WordPress**
- cr√©ation du fichier wp-pvc.yml
```
touch wp-pvc.yml
```
- cr√©ation du pvc
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl apply -f wp-pvc.yml 
persistentvolumeclaim/wp-pvc created
```
- v√©rification de la cr√©ation du persistentVolumeClaim wp-pvc
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get -n wordpress pvc
NAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
mysql-pvc   Bound    pvc-a331213c-7bb4-40be-bbbc-04e5f464017d   10Gi       RWO            standard       160m
wp-pvc      Bound    pvc-4e8a6364-29dc-4324-982a-5f22ec299477   5Gi        RWO            standard       4s
```
**f - wordpress Deployment**

**WordPress** √©tant une application **Stateless** c'est-√†-dire sans √©tat on peut se permettre d'utiliser un objet de type **Deployment**

- cr√©ation du fichier wp-deployment.yml 
```
touch wp-deployment.yml
```
- contenu du fichier
```
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress
  labels:
    app: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
      - image: wordpress:6.2.1-apache
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql-svc
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: WORDPRESS_DB_USER
          value: wordpress
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wp-pvc

```
Voici quelques points √† noter :

1 - **kind: Deployment** d√©mande √† Kubernetes de cr√©er une application WordPress avec les caract√©ristiques **Stateless**

2 - **replicas: 1** permettra de cr√©er un seul Pod sera nomm√© sous le format <deployment-name>-<[a-z0-9]al√©atoir> 

3 - **WORDPRESS_DB_HOST** ici on fournit le nom du service MySQL **mysql-svc** car c'est elle qui le endpoint de MySQL

4 - **WORDPRESS_DB_PASSWORD** est extrait de l'objet **Secret mysql-pass** √† l'aide de la ref√©rence **secretKeyRef**

5 - **image: wordpress:6.2.1-apache** est l'image qui servira √† la cr√©ation du Pod WordPress

6 - **volumeMounts et volumes** permettrons au r√©pertoire /var/www/html du Deployment d'√™tre mont√© dans le volume wp-pvc qui a √©t√© pr√©c√©demment cr√©e.

- cr√©ation du deployment wordpress
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl apply -f wp-deployment.yml 
deployment.apps/wordpress created
```
- v√©rification de la cr√©ation du deployment
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get -n wordpress deployments.apps 
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
wordpress   1/1     1            1           107s
```
- v√©rification du replicaset
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get -n wordpress rs
NAME                   DESIRED   CURRENT   READY   AGE
wordpress-6f77d9cd7c   1         1         1       7m38s
```
- v√©rification des pods 
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get -n wordpress pods 
NAME                         READY   STATUS    RESTARTS   AGE
mysql-0                      1/1     Running   0          90m
wordpress-6f77d9cd7c-ltc7v   1/1     Running   0          2m49s
```

**j - Service WordPress**

WordPress devant √™tre accessible depuis le navigateur donc exposer √† l'ext√©rieur du cluster , on va cr√©er un service de type **NodePort**  qui va exposer le service sur l'IP de chaque n≈ìud sur un port statique (le NodePort ) compris entre **30000 et 32767**

- Cr√©ation du fichier wp-svc.yml
```
touch wp-svc.yml
```
- Contenu du fichier wp-svc.yml
```
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress
  labels:
    app: wordpress
spec:
  ports:
    - port: 80
  selector:
    app: wordpress
    tier: frontend
  type: NodePort
```

*√† noter: le **selector** permet d'indexer le pod √† exposer*

- Cr√©ation du service **wordpress**
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl apply -f wp-svc.yml 
service/wordpress created
```

- V√©rification de la cr√©ation du service
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ kubectl get svc -n wordpress 
NAME        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
mysql-svc   ClusterIP   10.111.165.124   <none>        3306/TCP       96m
wordpress   NodePort    10.109.242.42    <none>        80:32640/TCP   90s
```
Comme on peut le constater le **port** attribu√© est **32640** qui en r√©alit√© va forwarder les requ√™tes r√©√ßues sur le port 80 du pod.

- Test de l'application via le Navigateur

- Url de l'application
```
gbane@dev-ops:~/Bureau/Mini-Projets/K8S/mini-projet-k8s$ minikube service wordpress -n wordpress --url
http://192.168.59.100:32640
```
<div align="center"><img src="images/wp.png" width=1000px></div><br>
<br><br>

<div align="center"><img src="images/wp-page.png" width=1000px></div>
